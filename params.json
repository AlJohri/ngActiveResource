{"name":"ngActiveResource","tagline":"Connects business objects and REST web services for Angular.js","body":"# ActiveResource for Angular.js\r\n\r\nActiveResource provides a Base class to make modelling with Angular easier. It\r\nprovides associations, caching, API integration, validations, and Active Record\r\npattern persistence methods.\r\n\r\n## Simple:\r\n\r\nSay you want a form to add comments to a post:\r\n\r\n    <form ng-submit=\"comment.$save\">\r\n      <input ng-model=\"comment.text\">\r\n      <input type=\"submit\">\r\n    </form>\r\n\r\n    <div ng-repeat=\"comment in post.comments\">\r\n      {{comment.text}}\r\n    </div>\r\n\r\nIn your controller, all you have to setup is something like this:\r\n\r\n    Post.find(postId).then(function(response) {\r\n      $scope.post      = response;\r\n      $scope.comment   = $scope.post.comments.new();\r\n\r\n      Comment.after('$save', function() {\r\n        $scope.comment = $scope.post.comments.new();\r\n      });\r\n    };\r\n\r\nYou don't even have to tell `ng-repeat` to load in the new comment. The new\r\ncomment will already be added to the post by association. Simply tell the\r\n`comment` object on the scope to clear, so that the user can enter another\r\ncomment.\r\n\r\n## Writing a Model:\r\n\r\nCreate an Angular factory or provider that relies on ActiveResource:\r\n\r\n    angular.module('app', ['ActiveResource')\r\n      .factory('Post', ['ActiveResource', function(ActiveResource) {\r\n\r\n        function Post(data) {\r\n          this.id = data.id;\r\n          this.hasMany('comments');\r\n          this.belongsTo('author);\r\n        };\r\n\r\n        Post = ActiveResource.Base.apply(Post);\r\n        Post.api.set('http://api.faculty.com');\r\n        Post.dependentDestroy('comments');\r\n\r\n        return User;\r\n      });\r\n\r\nThe model is terse, but gains a lot of functionality from ActiveResource.Base.\r\n\r\nIt declares a has-many relationship on Comment, allowing it to say things like:\r\n\r\n    var post    = Post.new({title: \"My First Post\"});\r\n    var comment = post.comments.new({text: \"Great post!\"});\r\n\r\nThe new comment will be an instance of the class Comment, which will be defined\r\nin its own model.\r\n\r\nIt also declares a belongs-to relationship on Author. This allows it to say\r\nthings like:\r\n\r\n    var author     = Author.new();\r\n    comment.author = author;\r\n    comment.$save().then(function(response) { comment = response; });\r\n\r\nThis will also cause author.comments to include this instance of Comment.\r\n\r\nPost also declares a dependent-destroy relationship on comments, meaning:\r\n\r\n    post.$delete().then(function(response) { post = comment = response; });\r\n    expect(post).not.toBeDefined();\r\n    expect(comment).not.toBeDefined();\r\n    expect(Post.find({title: \"My First Post\"}).not.toBeDefined();\r\n    expect(Comment.find({text: \"Great post!\"}).not.toBeDefined();\r\n\r\nThis means the post and its comments have been deleted both locally and from the\r\ndatabase.\r\n\r\nThe astute reader will notice methods prefaced with `$` are interacting with an\r\nAPI. The API calls are established in the model definition under\r\n`Post.api.set()`.\r\n\r\n## Establish Associations:\r\n\r\nA has many association can be setup by naming the field. If the field name is\r\nalso the name of the provider that contains the foreign model, this is all you\r\nhave to say. If the name of the provider is different, you can set it explicitly\r\nvia the `provider` option: \r\n\r\n    this.hasMany('comments', {provider: 'CommentModel'});\r\n\r\nForeign keys will also be intuited. For instance:\r\n\r\n    this.belongsTo('post');\r\n\r\nExpect the model to define a `post_id` attribute mapping to the primary key of\r\nthe post to which it belongs. If the foreign key is different, you can set it\r\nexplicitly: \r\n\r\n    this.belongsTo('post', {foreign_key: 'my_post_id'});\r\n\r\nAny number of options can be set on the association:\r\n\r\n    this.belongsTo('post', {provider: 'PostModel', foreign_key: 'my_post_id'});\r\n\r\n## Methods:\r\n\r\nActiveResource adds two types of methods to your models and instances:\r\n\r\n1) API-updating methods. These are prefaced with `$`, such as `$create`,\r\n`$save`, `$update`, and `$delete`, and are the 'unsafe' methods in a RESTful API \r\n(POST, PUT, and DELETE). These methods will call the API using the URLs you've\r\nset as ModelName.api.createURL, ModelName.api.updateURL, and ModelName.api.deleteURL.\r\nThe api.set method sets default API URLs for you, but you can override these defaults by setting\r\nthem explicitly.\r\n\r\n2) Local-instance creating and finding methods. These include `new`, `find`,\r\n`where`, and `update`. `new` creates a new instance of a model on the client,\r\nand `update` updates that instance without issuing a PUT request. `find` will\r\nattempt to find local instances in the model's client-side cache before issuing\r\na GET request, and `where` will always issue a GET request to ensure it has all\r\ninstances of a model that match given terms. These are the 'safe' methods in a\r\nRESTful API (GET).\r\n\r\n## Custom Primary Keys\r\n\r\nBy default, models will assume a primary key field labeled `id`, but you can set\r\na custom one like so:\r\n\r\n    function Post(data) {\r\n      primaryKey('_id');\r\n    }\r\n\r\n## Destroy Dependent Associations\r\n\r\nIf you want a model to delete certain associated resources when they themselves\r\nare deleted, use `dependentDestroy`:\r\n\r\n    Post.dependentDestroy('comments');\r\n\r\nNow when you destroy a post, any associated comments will also be destroyed.\r\n\r\n## Write Validations:\r\n\r\nModels can describe validations required before data will be persisted\r\nsuccessfully:\r\n\r\n    function User(data) {\r\n      this.name  = data.name;\r\n      this.email = data.email;\r\n\r\n      this.validates({\r\n        name: {presence: true},\r\n        email: { format: { email: { validates: true, message: 'Must provide valid email' } } } \r\n      });\r\n\r\nValidations also work with the Simple Form directive to perform easy form\r\nstyling. \r\n\r\n### Helper Methods:\r\n\r\n    user.valid\r\n    >> false \r\n\r\n    user.invalid\r\n    >> true\r\n\r\n    user.errors\r\n    >> { name: ['Must be defined'] }\r\n\r\n    user.validate('name')\r\n    >> true\r\n\r\n    user.validateIfErrored('name')\r\n    >> true\r\n    \r\n### Usage in Forms:\r\n\r\nHelper methods make form validation simple:\r\n\r\n    <input ng-model=\"user.name\" ng-blur=\"user.validate('name')\">\r\n    \r\nDisplaying errors is equally simple. Errors will only be added for a given field once it's been validated. Validate them one-by-one with directives like `ng-blur` or `ng-change`, or validate them all at once by passing no arguments to the `validate` method:\r\n\r\n    <div ng-show=\"user.errors.name\" class=\"alert alert-warning\">{{user.errors.name}}</div>\r\n\r\nThe interaction we prefer at Faculty Creative usually looks like this:\r\n\r\n    <input\r\n     ng-model=\"user.name\"\r\n     ng-blur=\"user.validate('name')\r\n     ng-change=\"user.validateIfErrored('name')>\r\n\r\nThis causes validations to run on blur, and, if errors exist on the field, to\r\nrun on change, so that as soon as a user corrects an error, the error will\r\ndisappear immediately.\r\n\r\nWhen a model instance is saved, all validations are automatically run, so errors\r\nwill appear if the form contains any errors.\r\n\r\n#### Presence:\r\n\r\nValidates that a user has entered a value:\r\n\r\n      name: {presence: true}\r\n\r\n#### Absence:\r\n\r\nValidates that a field does not have a value:\r\n\r\n      name: {absence: true}\r\n\r\n#### Length:\r\n\r\nValidates using ranges, min, max, or exact length:\r\n\r\n      username: { length: { in: _.range(1, 20); } },\r\n      email:    { length: { min: 5, max: 20 } },\r\n      zip:      { length: { is: 5 } }\r\n\r\n#### Format:\r\n\r\nValidates several built-in formats, and validates custom formats using the `regex`\r\nkey:\r\n\r\n      zip:   { format: { zip: true   } },\r\n      email: { format: { email: true } },\r\n      uuid:  { format: { regex: /\\d{3}\\w{5}/ } } \r\n\r\n#### Numericality:\r\n\r\nValidates that a value can be cast to a number. Can be set to ignore values like\r\ncommas and hyphens:\r\n\r\n      zip:    { numericality: { ignore: /[\\-]/g } }\r\n\r\n#### Acceptance: \r\n\r\nValidates truthiness, as in checkbox acceptance:\r\n\r\n      termsOfService: { acceptance: true }\r\n\r\n#### Inclusion:\r\n\r\nValidates inclusion in a set of terms:\r\n\r\n      size: { inclusion: { in: ['small', 'medium', 'large'] } }\r\n\r\n#### Exclusion:\r\n\r\nValidates exclusion from a set of terms:\r\n\r\n      size: { exclusion: { from: ['XS', 'XL'] } } \r\n\r\n#### Confirmation:\r\n\r\nValidates that two fields match:\r\n\r\n      password:             { confirmation: true },\r\n      passwordConfirmation: { presence: true }\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}